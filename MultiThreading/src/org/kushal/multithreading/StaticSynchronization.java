package org.kushal.multithreading;

// Whenever we use synchronize keyword JAVA applies some locking mechanism, in below 
//we use 2 different objects on BracketsStatic, we can get some inconsistent output 
//since these synchronization is done on the based of object.

// So to solve this problem we will use static synchronization technique is used.
// In below code mark the method as static AND WE MARK THE ANY STATIC ELEMENT AS 
//SYNCHRONIZED THEN LOCK WOULD BE BASED ON CLASS DIRECTLY.

class BracketsStatic {

	synchronized static public void generate(String threadCode) {
		for (int i = 1; i < 10; i++) {
			try {
				Thread.sleep(10);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			if (i <= 5) {
				System.out.print("{");
			} else {
				System.out.print("}");
			}
		}
		System.out.println("Generated by thread " + threadCode);
	}
}

public class StaticSynchronization {

	public static void main(String[] args) {

		// BracketsStatic brackets1 = new BracketsStatic("Thread1");
		// BracketsStatic brackets2 = new BracketsStatic("Thread2");
		new Thread(new Runnable() {

			@Override
			public void run() {
				long startTime = System.currentTimeMillis();
				for (int i = 1; i < 10; i++) {
					BracketsStatic.generate("Thread 1");

				}
				long endTime = System.currentTimeMillis();
				System.out.println("Time Required for Thread 1 is " + (endTime - startTime));
			}
		}).start();

		new Thread(new Runnable() {

			@Override
			public void run() {
				long startTime = System.currentTimeMillis();
				for (int i = 1; i < 10; i++) {
					BracketsStatic.generate("Thread 2");
				}
				long endTime = System.currentTimeMillis();
				System.out.println("Time Required for Thread 2 is " + (endTime - startTime));

			}
		}).start();
	}
}
